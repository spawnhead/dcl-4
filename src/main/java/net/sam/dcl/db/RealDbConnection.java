package net.sam.dcl.db;

import net.sam.dcl.config.Config;
import net.sam.dcl.util.HibernateUtil;


import java.sql.*;

import org.apache.commons.logging.LogFactory;
import org.apache.commons.logging.Log;

/**
 * The class  <code>net.sam.dcl.db</code> represents
 * connect to the database in the system.
 */

public class RealDbConnection {
	static short RUN_MODE__AUTO_COMMIT = 0x0001;

	Connection conn;

	//private  short        mConnType               ;
	private int mUseCount;
	private Integer mMutexUseCount;
	private int mUseStmt;
	private Integer mMutexUseStmt;
	private int mBusy;
	private Integer mMutexBusy;
	private boolean mBeginTransaction;
	private Integer mMutexBeginTransaction;

	private int mRecordSetTypeScroll;

	private long mTotalUsingNumber;
	private Timestamp mOpenedTime;
	private Timestamp mLastUsingTime;

	private long mDbPoolInstanceNumber;

	public static final Log log = LogFactory.getLog(RealDbConnection.class);

	/**
	 * Construct <code>RealDbConnection</code> object and gets connect to the specified
	 * database server.
	 */

	RealDbConnection(String connectionUrl, String dbuser, String dbpassword, short connType, long dbPoolInstanceNumber)
			throws VDbException {
		Init();

		mDbPoolInstanceNumber = dbPoolInstanceNumber;

		try {
			conn = DriverManager.getConnection(connectionUrl, dbuser, dbpassword);

      if (!Config.getString("db.version").equals(conn.getMetaData().getDatabaseProductVersion())){
				throw new VDbException("Unsupported DB version:"+conn.getMetaData().getDatabaseProductVersion());
		  }


			//mConnType = connType ;

			if ((connType & RUN_MODE__AUTO_COMMIT) != 0) {
				conn.setAutoCommit(true);
			} else {
				conn.setAutoCommit(false);
			}
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber);
		}
	}

	/**
	 * Initializes states of this object.
	 */
	private void Init() {
		conn = null;
		mUseCount = 0;
		mMutexUseCount = new Integer(0);
		mUseStmt = 0;
		mMutexUseStmt = new Integer(0);
		mBusy = 0;
		mMutexBusy = new Integer(0);
		mBeginTransaction = false;
		mMutexBeginTransaction = new Integer(0);

		mRecordSetTypeScroll = ResultSet.TYPE_FORWARD_ONLY;
		//TYPE_SCROLL_INSENSITIVE;
		//TYPE_SCROLL_SENSITIVE;
		mTotalUsingNumber = 0;
		mOpenedTime = new Timestamp(System.currentTimeMillis());
		mLastUsingTime = null;

		mDbPoolInstanceNumber = 0;
	}

	/**
	 * set auto commit
	 */
	synchronized void setAutoCommit(boolean autoCommit) throws VDbException {
		try {
			conn.setAutoCommit(autoCommit);
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber);
		}
	}

	/**
	 * Creates </code>Statement</code> object for sending SQL statements to the database.
	 */

	synchronized Statement createStatement() throws VDbException {
		Statement stmt = null;
		incBusy();
		try {
			stmt = conn.createStatement(mRecordSetTypeScroll, ResultSet.CONCUR_READ_ONLY);
			incUseStmt();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber);
		}
		finally {
			decBusy();
		}

		return stmt;
	}

	/**
	 * Creates </code>PrepearedStatement</code> object for sending parameterized
	 * SQL statements to the database.
	 */
	synchronized PreparedStatement createPreparedStatement(VDbExecutionContext executionContext) throws VDbException {
		PreparedStatement stmt = null;
		incBusy();
		try {
			stmt = conn.prepareStatement(executionContext.getSql(), mRecordSetTypeScroll, ResultSet.CONCUR_READ_ONLY);
			incUseStmt();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber, executionContext);
		}
		finally {
			decBusy();
		}
		return stmt;
	}

	/**
	 * Creates </code>CallableStatement</code> object for sending parameterized
	 * SQL statements to the database.
	 */
	synchronized CallableStatement createCallableStatement(VDbExecutionContext executionContext) throws VDbException {
		CallableStatement stmt = null;
		incBusy();
		try {
			stmt = conn.prepareCall(executionContext.getSql());
			incUseStmt();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber, executionContext);
		}
		finally {
			decBusy();
		}
		return stmt;
	}

	/**
	 * Executes the SQL query in this object
	 * and returns the result set generated by the query.
	 */
	synchronized ResultSet executeQuery(Statement stmt, VDbExecutionContext executionContext) throws VDbException {
		ResultSet rset = null;
		incBusy();
		try {
			toLog(executionContext);
      setCurrentUser();
			rset = stmt.executeQuery(executionContext.getSql());
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber, executionContext);
		}
		finally {
			decBusy();
		}


		return rset;
	}

	/**
	 * Executes the prepared SQL query in this object
	 * and returns the result set generated by the query.
	 */
	synchronized ResultSet executeQuery(PreparedStatement stmt, VDbExecutionContext executionContext) throws VDbException {
		ResultSet rset = null;
		incBusy();
		try {
			toLog(executionContext);
      setCurrentUser();
			rset = stmt.executeQuery();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber, executionContext);
		}
		finally {
			decBusy();
		}

		return rset;
	}

	/**
	 * Executes the SQL INSERT,UPDATE or DELETE statement
	 * in this object.
	 */
	synchronized int executeUpdate(String user, Statement stmt, VDbExecutionContext executionContext) throws VDbException {
		int ret;
		incBusy();
		try {
			toLog(executionContext);
			setCurrentUser();
			ret = stmt.executeUpdate(executionContext.getSql());
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber, executionContext);
		}
		finally {
			decBusy();
		}

		return ret;
	}

	/**
	 * Executes the SQL INSERT,UPDATE or DELETE parameterized statement
	 * in this object.
	 */
	synchronized int executeUpdate(String user, PreparedStatement stmt, VDbExecutionContext executionContext) throws VDbException {
		int ret;
		incBusy();
		try {
			toLog(executionContext);
			setCurrentUser();
			ret = stmt.executeUpdate();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber, executionContext);
		}
		finally {
			decBusy();
		}

		return ret;
	}

	/**
	 * Executes any kind of SQL statement.
	 */
	synchronized boolean execute(String user, Statement stmt, VDbExecutionContext executionContext) throws VDbException {
		boolean ret;
		incBusy();
		try {
			toLog(executionContext);
			setCurrentUser();
			ret = stmt.execute(executionContext.getSql());
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber, executionContext);
		}
		finally {
			decBusy();
		}

		return ret;
	}

	/**
	 * Executes any kind of SQL statement.
	 */
	synchronized boolean execute(String user, PreparedStatement stmt, VDbExecutionContext executionContext) throws VDbException {
		boolean ret;
		incBusy();
		try {
			toLog(executionContext);
			setCurrentUser();
			ret = stmt.execute();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber, executionContext);
		}
		finally {
			decBusy();
		}

		return ret;
	}

	/**
	 * Executes a callable satement.
	 */
	synchronized boolean executeCall(String user, CallableStatement stmt, VDbExecutionContext executionContext) throws VDbException {
		boolean ret;
		incBusy();
		try {
			toLog(executionContext);
			setCurrentUser();
			ret = stmt.execute();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber, executionContext);
		}
		finally {
			decBusy();
		}

		return ret;
	}

	/**
	 * Gets database meta data.
	 */
	synchronized DatabaseMetaData getMetaData() throws VDbException {
		incBusy();
		try {
			return conn.getMetaData();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber);
		}
		finally {
			decBusy();
		}
	}

	/**
	 * Makes all changes made since the previous
	 * commit/rollback permanent and releases any database locks
	 * currently held by the Connection.
	 */
	synchronized void commit() throws VDbException {
		try {
			toLog("commit");
			//
			if (conn != null) conn.commit();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber);
		}
		finally {
			endTransaction();
		}
	}

	/**
	 * Drops all changes made since the previous
	 * commit/rollback and releases any database locks currently held
	 * by this Connection.
	 */
	synchronized void rollback() throws VDbException {
		try {
			toLog("rollback");
			//
			if (conn != null) conn.rollback();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber);
		}
		finally {
			endTransaction();
		}

	}

	/**
	 * Closes the connection.
	 */
	synchronized void close() throws VDbException {
		try {
			if (conn != null) conn.close();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber);
		}
		finally {
			endTransaction();
			conn = null;
		}
	}

	protected void finalize() {/*
   try
   {
    if( conn != null )conn.close();
   }
   catch(SQLException e )
   {
    Tracer.action_trace (Tracer.EXCEPTION     ,
                        DbConnection.class    ,
                        "finalize"            ,
                        e.getMessage()        );
   }*/
		conn = null;
	}


	synchronized void closeStmt(Statement stmt) throws VDbException {
		// in Oracle it's synchronized
		try {
			if (stmt != null) stmt.close();
		}
		catch (SQLException e) {
			throw new VDbException(e, mDbPoolInstanceNumber);
		}
		finally {
			if (stmt != null) decUseStmt();
		}
	}

	//****************************************************************************

	/**
	 * Closes the recordset.
	 */
	/*
		void closeCursor(ResultSet rset )    throws VDbException
		{
		 // in Oracle it's synchronized
		 try
		 {
			rset.close(); decUseCursor();
		 }
		 catch(SQLException e){ throw new VDbException(e,mDbPoolInstanceNumber); }
		}*/

	/**
	 * Starts transaction for this connection.
	 */

	synchronized boolean beginTransaction() {
		synchronized (mMutexBeginTransaction) {
			if (mBeginTransaction == true) {
				return false;
			} else {
				mBeginTransaction = true;
				toLog("begin transaction");
				return true;
			}
		}
	}

	/**
	 * Checks if the transaction started.
	 * This  function is had to use in synchronized (DbConnection) block with
	 * beginTransaction
	 */
	boolean isTransaction() {
		synchronized (mMutexBeginTransaction) {
			return mBeginTransaction;
		}
	}

	/**
	 * Ends the transactions for this connection.
	 */
	synchronized void endTransaction() {

		synchronized (mMutexBeginTransaction) {
			mBeginTransaction = false;
		}

	}

	/**
	 * Incremetns the count of use.
	 */

	void incUseCount() {
		synchronized (mMutexUseCount) {
			mUseCount++;
			mTotalUsingNumber++;
			mLastUsingTime = new Timestamp(System.currentTimeMillis());
		}
	}

	/**
	 * Decrements the count of use.
	 */
	void decUseCount() {
		synchronized (mMutexUseCount) {
			mUseCount--;
		}
	}

	/**
	 * Gets the count of use.
	 */
	int getUseCount() {
		synchronized (mMutexUseCount) {
			return mUseCount;
		}
	}

	/**
	 * Incremetns the count of use of a statement.
	 */
	private void incUseStmt() {
		synchronized (mMutexUseStmt) {
			mUseStmt++;
		}
	}

	/**
	 * Decrements the count of use of a statement.
	 */
	private void decUseStmt() {
		synchronized (mMutexUseStmt) {
			mUseStmt--;
		}
	}

	/**
	 * Gets the count of use of a statement.
	 */

	int getUseStmt() {
		synchronized (mMutexUseStmt) {
			return mUseStmt;
		}
	}

	/**
	 * Sets the connection busy.
	 */

	private void incBusy() {
		synchronized (mMutexBusy) {
			mBusy++;
		}
	}

	/**
	 * Resets the connectin busy.
	 */
	private void decBusy() {
		synchronized (mMutexBusy) {
			mBusy--;
		}
	}

	/**
	 * Return true if the connection is busy.
	 */
	boolean isBusy() {
		synchronized (mMutexBusy) {
			return mBusy == 0 ? false : true;
		}
	}

	/**
	 * Diagnostics
	 * Gets the total number of use.
	 */
	long getTotalUsingNumber() {
		return mTotalUsingNumber;
	}

	/**
	 * Diagnostics
	 * Gets the total number of use.
	 */
	Timestamp getOpenedTime() {
		return mOpenedTime;
	}

	/**
	 * Diagnostics
	 * Gets the last using time.
	 */
	Timestamp getLastUsingTime() {
		return mLastUsingTime;
	}

	long getDbPoolInstanceNumber() {
		return mDbPoolInstanceNumber;
	}

	/**
	 * saves sql statement to log file
	 */
	private void toLog(String sql) {
		if (VDbConnectionManager.traceEnabled == false) return;
		log.info(sql);
	}

	private void toLog(VDbExecutionContext executionContext) {
		if (VDbConnectionManager.traceEnabled == false) return;

				log.info(executionContext.toString());

	}

	/**
	 * for audit purpose .
	 * function works in collaboration with execute , executeUpdate and executeCall
	 * and sets a user who is currently working with this function.
	 * the flag busy isn't set becouse this function is private and woks only
	 * in collaboratin with other functions where this flag has been set yet.
	 */
	private void setCurrentUser() throws VDbException {
    try {
      HibernateUtil.DCLConnectionProvider.setUserToConnecton(conn);
    } catch (SQLException e) {
      throw new VDbException(e,mDbPoolInstanceNumber);
    }
  }
}
